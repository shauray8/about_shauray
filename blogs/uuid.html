<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>UUIDs - Mess Withing a Widely Used Standard</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="Discovering secret seeds in Text-to-Image Diffusion Models">
    <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Shauray Singh blog posts" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="main.css">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1DD05WB973"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RLJ3MKG26H');
    </script>

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="./blog.html">We Must Know, We Will Know</a>
    
</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>UUIDs - Mess Withing a Widely Used Standard</h1>
    <p class="meta">Jun 18, 2024</p>
  </header>

  <article class="post-content">
  <style>
.post-header h1 {
    font-size: 35px;
}
.post pre,
.post code {
    background-color: #fcfcfc;
    font-size: 13px; /* make code smaller for this post... */
}
</style>

<p>It's time to dive into the wild, wacky, and sometimes downright infuriating world of UUIDs. Yes, those strings of alphanumeric chaos that we love to hate and hate to love We're not here to explain what UUIDs are (Google that if you must), but rather to vent, rant, and explore some wild ideas about how V7 can help in some ways, specially with S3s (S3s requires a seperate rant of it's own)</p>
<h3>A quick overview of what a mess of versions it is !</h3>
<p>I really like this illustration from <a href='https://www.youtube.com/@t3dotgg/'>@t3dotgg</a> and this post <a href='https://planetscale.com/blog/the-problem-with-using-a-uuid-primary-key-in-mysql'>The Problem with Using a UUID Primary Key in MySQL</a> will give you a very good explaination of how messed up this is, which basically translates to, <br> </p>
<ul>
  <li> <b>UUIDv1</b> - Uses the Gregorian calendar &#x1F937;&#x200D;&#x2642;&#xFE0F; segments looks like <b>['time_low'-'time_mid'-'time_low_and_version'-'clock_seq_and_version'-'node'] </b>- now using the Gregorian calendar is not the biggest issues here, rather they had the biggest segment set to <b>'node'</b> which is the unique address of the system generating the UUID. I'm no security expert but this looks bad </li>
  <br>
  <li> <b>UUIDv2</b> - nothing intresting here, they replaced the <b>'low_time'</b> component of the UUID with POSIX user ID </li>
  <br>
  <li><b>UUIDv3 and v5</b> - they started using a <b>128bit</b> hash and both versions use a different hash MD5 and SHA1 repectively, the intresting part here is that V3 and V5 is similar but not V4, and V4 is what is widely used</li>
  <br>
  <li><b>UUIDv4</b> - this is what most of the population uses for there random keys and in my opinion this is the simplest of them all, <b>it just uses a set of random alphanumerics</b>, with an exception that the first position of the 3rd segment is always set to the version number (seen throughout the versions) </li>
  <br>
  <li><b>UUIDv6</b> - now V6 is very similar to V1 flipping the timestamps, meaning the most significant portions of the timestamp are stored first. now in turn this makes it a little more <b>sortable</b>, since the most significant portion of the timestamp is upfront</li>
  <br>
  <li><b>UUIDv7</b> - now this is the only version I can think of using in come cases instead of V4, this basically finally uses the <b>UNIX timestamp</b> instead of the Gregorian calendar and the rest of the string is just random alphanumerics, which makes it less trackable back to their source and this is what we will discuss moving forward</li>
  <br>
  <li><b>UUIDv8</b> - this permits vendor-specific implementations while adhering to RFC standards and the illustration says its more of a vibe then a standard now</li>
</ul>

<img src="./assets/uuid.png", width='100%'></img>
<h3>UUIDv7 and Simple Storage Solutions (or databases in general)</h3>
<p style="color: red"><b>! There are very good guides on how diffusion works online this is just a sparse introduction to the diffusion process to build up the notion !</b></p>
<p>The diffusion process is an iterative mechanism that converts random noise into an image. This process can be broadly divided into two stages: forward diffusion and reverse diffusion. Let's delve into these stages to understand their technical intricacies.</p>
<h3>Trees 101</h3>
<p>Now Trees, with there hierarchical strcutre, play a pivotal role in all of computer science in my opinion also providing a backbone for storing indeces for huge databases, (If you don't know about Trees consider taking one of the MIT OCW courses on data structres), for now we will talk about B-Trees often called as balanced trees but it's not really known that the B stands for in the B-Trees, also we'll talk about B+ Trees which is a much more widely accepted data structure when storing huge amounts of data </p>

<h4>B Trees</h4>
<p>! Keeping in mind that the memory is not contiguous rather heirarchical !</p>
<p>Assuming you know about BSTs, we'll work with a modification of that consider that now every node can store two keys, now you have 3 paths to take when searching for a key very similar to what you would do for a binary search tree, now to formalize this, each node in a B-Tree of order d contains at most 2d keys and 2d+1 pointers as shown below, now the keys can vary from node to node, but each must have at least d keys and d+1 pointers, such that every node is atleast half full</p>
<img src="./assets/btree.png" width='100%'></img>
<p>Balancing a B-Tree : with BST random insertions can leave a tree unbalanced which in turn makes it harder to find a key(atleast the worst case senario), with B-Trees the longest path is logdn, now with this you will never visit more then 1+logdn nodes</p>
<img src='./assets/complex.png' width='100%'></img>
<p>Insertion : First, a find proceeds from the root to locate the proper leaf for insertion. Then the insertion is performed, and balance is restored by a procedure which moves from the leaf back toward the root.</p>
<p>Deletion : Deletion in a B-tree also requires a find operation to locate the proper node. There are then two possibilities: the key to be deleted resides in a leaf, or the key resides in a nonleaf node. A nonleaf deletion requires that an adjacent key be found and swapped into the vacated position so that it finds work correctly</p>

<p>Now with these there is a notion of underflow in the leaves as a minimum of d keys is required so in order to restore the balance a key is borrowed from its neighbour, and if there are'nt enough keys to destribute a concatenate happens to restore the balance</p>

<h4>B+ Trees</h4>
<p>With B+ Tree, all the keys reside in the leaves, the upper levels , which are organized as a B-Tree, consists only of the index.</p>
<p>
Structure of B+ Tree
<ul>
  <b>If a node is a non-leaf node:</b>
  <li>x.n the number of route values currently stored in node x</li>
  <li>the route values stored in node x in increasing order - x.router1 &lt; x.router2 </li>
  <li>x.leaf, a boolean field whose value is FALSE meaning that x is a non-leaf node</li>
  <li>x.n + 1 pointers x.c1, x.c2 ... x.cx.n+1 to the children of x</li>

  <b>If a node is a leaf node:</b>
  <li>x.n number of key values currently stored in x</li>
  <li>the key value stored in node x in increasing order : x.key1 &lt; x.key2</li>
  <li>x.leaf, a boolean field whose value is TRUE meaning that x is a leaf node</li>
</ul>
<img src="./assets/bplusacc.png" width="100%"></img>
<p>Some intresting properties of a B+ Tree :</p>
<p>
<ul>
  <li>every leaf node has the same depth which is the height of the tree</li>
  <li>Every node of the B+-tree except the root node is at least half-filled.</li>
  <br>
  <p style="color:green">Very similar to what a B-Tree has</p>
</ul>
Now beacause the B+ Tree satisfies the given balance condition, we can prove that the height h of the B+ Tree 
h less then or equal to logtn
</p>
<p>Also searching in a B+ Tree is very similar to how a B-Trees does it, with an exception being that it always terminates at the leaf node</p>

<p>Insertion and Deletion for B+ Trees</p>
<p>
The insertion of the key k to a B+-tree is started by searching for the leaf node y which should contain k. This is performed in the same way as when performing the B+-tree-search operation. If there is enough space in y to insert the key k, k is inserted and no other actions are needed

The compexity comes where the node y is full before the insertion, it must be split as follows:
<ul>
  <li>We allocate memory for a new node z.</li>
  <li>the first t keys of node y are left in y</li>
  <li>the last t keys of node y are transferred to the new node z.</li>
  <li>the key k is inserted to either nodee y or z according to the value of k</li>
  <li>A pointer to the new node z and a new router value are inserted to node x which is the parent of both y and z. A good choice for the new router value is the last key value in y.</li>
  <li>If there is not enough space for a new pointer and router value in x, x must be split. In the worst case, all nodes in the path from the leaf to the root must be split which is rather intresting as with B+ Trees we grow the root rather then growing the leaves</li>
  <br>
  <li>while deletion, we do not remove the key value from non-leaf nodes </li>
  <li>the first t keys of node y are left in y</li>
  <li>the last t keys of node y are transferred to the new node z.</li>
  <li>the key k is inserted to either nodee y or z according to the value of k</li>
  <li>A pointer to the new node z and a new router value are inserted to node x which is the parent of both y and z. A good choice for the new router value is the last key value in y.</li>
  <li>If there is not enough space for a new pointer and router value in x, x must be split. In the worst case, all nodes in the path from the leaf to the root must be split which is rather intresting as with B+ Trees we grow the root rather then growing the leaves</li>
</ul>
</p>


<h3><b>Optimizing insertions for B+ Trees</b></h3>
<p>Now optimizations is where we do have to remember the heirarchical structure of the memory</p>
<p>
Standard B+ Tree implementations, while theoretically elegant, often suffer from severe performance degradation when faced with real-world, high-throughput scenarios. Let's dissect the primary bottlenecks:
<ul>
  <li><b>Root-to-leaf Traversal Overhead</b>: Each random insertion necessitates a complete traversal from root to leaf. In large-scale systems, this results in O(log n) I/O operations per insertion, which becomes prohibitively expensive as n grows.</li>
  <li><b>Cache-Unfriendly Random Page Modifications </b>: The stochastic nature of insertions leads to unpredictable page modifications across the tree structure. This behavior is anathema to modern CPU cache architectures, resulting in frequent cache misses and suboptimal memory access patterns.
</li>
<li><b>Underutilized Leaf Nodes</b> : Typical B+ Tree implementations maintain leaves at approximately 50% capacity to facilitate splits and merges. While this simplifies rebalancing operations, it leads to significant wasted space and increased tree depth.</li>
</ul>
The root cause of these inefficiencies lies in the use of <b>randomly distributed key indices</b>. This randomness, while beneficial for even distribution, wreaks havoc on locality of reference and predictable access patterns.
</p>
<p>
Leveraging Sorted Insertions for Optimized Performance : 

Implementing a sorted insertion strategy can mitigate these issues substantially:
<ol>
  <li><b><i>Localized Page Access</i></b>: By maintaining insertions on the rightmost path of the tree, we dramatically improve cache utilization. This approach allows for prefetching and reduces TLB misses.</li>
  <li><b><i>Controlled Fill Factor</i></b>: Sorted insertions enable precise control over leaf node utilization. By maintaining a higher fill factor (e.g., 80-90%), we can significantly reduce the overall tree depth and improve space efficiency.</li>
  <li><b><i>Sequential Disk Layout</i></b>: Sorted keys naturally lead to a more contiguous on-disk representation of leaf nodes. This alignment with underlying storage characteristics can yield substantial I/O performance gains, especially on HDDs or SMR drives.</li>
</ol>

</p>
<p>
UUIDv7: The Nexus of Uniqueness and Sortability
The advent of UUIDv7 provides an elegant solution to the seemingly contradictory requirements of unique identifiers and sortable keys. By encoding a high-precision timestamp in the most significant bits, UUIDv7 offers:

<ol>
  <li> <b>Temporal Sorting</b>: Keys are naturally ordered by creation time, facilitating the sorted insertion optimizations discussed above.</li>
  <li> <b>Maintained Uniqueness</b>: The inclusion of random bits ensures collision resistance even in high-concurrency environments.</li>
  <li> <b>Distributed Generation</b>: UUIDs can be generated without coordination, crucial for distributed systems.</li>

this is where UUIDv7 comes in, with this the first segment of the alphanumeric is not random but rather the UNIX time, which in turn makes the UUIDs sortable, which enables us to use the above stated optimizations 
</ol>
</p>
<h3>Empirical Observations and Hypotheses</h3>
<p>While the exact implementations of large-scale object storage systems like AWS S3 or Cloudflare R2 are not public, observed behavior suggests potential B+ Tree-like underpinnings. Specifically, the correlation between bucket size and post-handshake upload latency hints at tree rebalancing operations as a potential bottleneck.
</p>
<p>Given that a production-grade B+ Tree with a depth of 2 can easily accommodate millions of entries, the optimizations proposed here could yield significant benefits:

<ol>
  <li><b>Reduced Rebalancing Frequency</b>: Sorted insertions naturally lead to fewer tree restructuring operations.</li>
  <li><b>Improved Cache Efficiency</b>: By localizing insertions to a specific region of the tree, we can maintain critical pages in cache for extended periods.</li>
  <li><b>Enhanced I/O Patterns</b>: The more predictable nature of insertions allows for more effective I/O scheduling and potential write coalescing.</li>
</ol>

</p>
<h3>Conclusion and Future Directions</h3>
<p>While these optimizations offer substantial improvements, they are not a panacea for all storage system designs. The efficacy of these approaches depends heavily on workload characteristics and system requirements.

Future research directions might include:

<ul>
  <li>Adaptive algorithms that dynamically adjust between random and sorted insertion strategies based on observed workload patterns.</li>
  <li>Integration with emerging storage technologies like ZNS SSDs to further optimize physical data layout.</li>
  <li>Exploration of hybrid data structures that combine the strengths of B+ Trees with other indexing mechanisms for specific use cases.</li>
</ul>
As we continue to push the boundaries of large-scale data management, such optimizations will become increasingly crucial. The intersection of data structure design, systems architecture, and hardware characteristics remains a fertile ground for innovation in the pursuit of performant and scalable storage solutions.</p>
<h5> Related Work </h5>
<p style="font-size:12px">arXiv:2404.11120, arXiv:2404.04650, arXiv:2312.08872 and others have aimed to optimize the initial noise to produce images that better align with the text prompt, reduce visual artifacts, or achieve a desired layout
    </body>
</html>
